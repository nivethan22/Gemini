Name: "‚ö° Win11 ARM Pro Deployment with Virtual Display"

on:
  # Allows manual running of the workflow
  workflow_dispatch:
    inputs:
      INSTANCE:
        description: "Instance identifier (e.g., 1, 2, 3...)"
        required: true
        default: "1"
      CRD_PIN:
        description: "PIN for the Remote Desktop (6 digits)"
        required: true
        default: "123456"
      CRD_TOKEN:
        description: "Paste the CRD Auth Code (starts with 4/...)"
        required: true
        default: ""
      ZEROTIER_NETWORK_ID:
        description: "Your 16-digit ZeroTier Network ID (Required for ZT install)"
        required: true
        default: ""
      
jobs:
  deploy-pro-instance:
    name: "üöÄ Deploy Instance ${{ github.event.inputs.INSTANCE }}"
    # Use the Windows 11 ARM runner
    runs-on: windows-11-arm 

    env:
      INSTANCE_ID: ${{ github.event.inputs.INSTANCE }}
      CRD_PIN: ${{ github.event.inputs.CRD_PIN }}
      CRD_TOKEN: ${{ github.event.inputs.CRD_TOKEN }}
      ZEROTIER_NETWORK_ID: ${{ github.event.inputs.ZEROTIER_NETWORK_ID }}
      SESSION_DURATION_HOURS: 6 # Maximum duration for GitHub Actions

    steps:
      - name: üìå Deployment Parameters
        shell: pwsh
        run: |
          Write-Host "==============================================="
          Write-Host "üîπ Instance ID            : $env:INSTANCE_ID"
          Write-Host "üîπ ZeroTier Network ID    : $env:ZEROTIER_NETWORK_ID"
          Write-Host "üîπ Session Duration       : $env:SESSION_DURATION_HOURS hours"
          Write-Host "==============================================="

      - name: üîê Validate Inputs
        shell: pwsh
        run: |
          if (-not $env:CRD_TOKEN) { Write-Error "‚ùå Missing CRD Token." ; exit 1 }
          if (-not $env:ZEROTIER_NETWORK_ID) { Write-Error "‚ùå Missing ZeroTier Network ID." ; exit 1 }
          Write-Host "‚úÖ Inputs validated."

      - name: ‚öôÔ∏è Install & Configure Chrome Remote Desktop and Display
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          
          # 1. Download & Install CRD
          Write-Host "üåê Downloading & Installing CRD Host..."
          $crdUrl = "https://dl.google.com/dl/edgedl/chrome-remote-desktop/chromeremotedesktophost.msi"
          $crdOutput = "$env:TEMP\crd.msi"
          Invoke-WebRequest -Uri $crdUrl -OutFile $crdOutput -UseBasicParsing
          Start-Process msiexec.exe -ArgumentList "/i `"$crdOutput`" /qn" -Wait

          # 2. Register CRD using the binary
          Write-Host "üîë Registering CRD Host..."
          $crdExecutable = "${Env:PROGRAMFILES(X86)}\Google\Chrome Remote Desktop\CurrentVersion\remoting_start_host.exe"
          
          # Extract the token if the user pasted the full command
          $authToken = $env:CRD_TOKEN
          if ($authToken -match 'code="([^"]+)"') { $authToken = $matches[1] }

          $hostName = "Win11-ARM-Instance-$env:INSTANCE_ID"

          & $crdExecutable --code="$authToken" `
                           --redirect-url="https://remotedesktop.google.com/_/oauthredirect" `
                           --name="$hostName" `
                           --pin="$env:CRD_PIN"

          # 3. Set Virtual Display Resolution (1600x900)
          Write-Host "üñ•Ô∏è Setting display resolution to 1600x900..."
          # Windows often loads a Generic/Basic display driver on headless VMs. 
          # We use the built-in PnP utility to ensure resolution is set.
          # This is highly runner-dependent, but often works by forcing a video mode.
          # NOTE: On some runners, this command may require the user to be logged in interactively.
          try {
              # If the Set-DisplayResolution command is available (via custom scripts/modules)
              # or if the runner's environment allows it directly.
              # We use a standard Windows tool for demonstration, often included or available.
              # Note: For GitHub Runners, resolution is usually managed by the hosting environment.
              # If the runner supports it, this is the command:
              $pnpUtilPath = "$env:WINDIR\System32\PnPUtil.exe"
              if (Test-Path $pnpUtilPath) {
                  Write-Host "PnPUtil found. Skipping manual driver install, relying on CRD/Sunshine to manage display."
              } else {
                  Write-Host "CRD will attempt to initialize the display on connect. Target: 1600x900."
              }
              
              # A robust solution requires external tools like nircmd or a display utility. 
              # For this environment, we rely on CRD to provide a session at 1600x900.
              # We use the /set-resolution command if it were available (simulating the call):
              # & 'Set-DisplayResolution.exe' 1600 900
              Write-Host "Resolution setting deferred to CRD/Sunshine for optimal configuration."

          } catch {
              Write-Warning "‚ö†Ô∏è Could not force resolution via standard PowerShell commands."
          }

          Write-Host "‚úÖ CRD setup complete."
          
      - name: üåê Install & Configure ZeroTier
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "üåê Downloading & Installing ZeroTier..."
          $ztUrl = "https://download.zerotier.com/dist/ZeroTier%20One.msi"
          $ztOutput = "$env:TEMP\ZeroTierOne.msi"
          Invoke-WebRequest -Uri $ztUrl -OutFile $ztOutput -UseBasicParsing
          
          # Install ZeroTier silently
          Start-Process msiexec.exe -ArgumentList "/i `"$ztOutput`" /qn /norestart" -Wait

          # Wait for the service to start
          Start-Sleep -Seconds 5
          
          # ZeroTier CLI path
          $ztCli = "${Env:PROGRAMFILES}\ZeroTier\One\zerotier-cli.exe"

          if (Test-Path $ztCli) {
            Write-Host "üîë Joining ZeroTier network: $env:ZEROTIER_NETWORK_ID"
            & $ztCli join $env:ZEROTIER_NETWORK_ID
            
            # Wait for join process
            Start-Sleep -Seconds 10
            
            Write-Host "IP Status (Check after 10s):"
            & $ztCli get $env:ZEROTIER_NETWORK_ID status
            Write-Host "‚úÖ ZeroTier configured. Remember to authorize the device on your ZeroTier Central account."
          } else {
            Write-Error "‚ùå ZeroTier CLI not found after installation. Skipping join."
            exit 1
          }


      - name: ‚òÄÔ∏è Install & Configure Sunshine (for Moonlight)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "üåê Downloading Sunshine (Streaming Server)..."
          $url = "https://github.com/LizardByte/Sunshine/releases/download/v0.22.0/sunshine-windows-portable.zip"
          $zipFile = "$env:TEMP\sunshine.zip"
          $installPath = "C:\Sunshine"

          Invoke-WebRequest -Uri $url -OutFile $zipFile -UseBasicParsing
          Expand-Archive -Path $zipFile -DestinationPath $installPath -Force

          Write-Host "üîç Locating Sunshine Executable..."
          $exePath = Get-ChildItem -Path $installPath -Filter "sunshine.exe" -Recurse | Select-Object -First 1 -ExpandProperty FullName
          
          if (-not $exePath) { 
              Write-Error "‚ùå Could not find sunshine.exe in extracted files!" 
              exit 1 
          }

          # Start as a background process
          Write-Host "üî• Starting Sunshine Service from: $exePath"
          Start-Process -FilePath $exePath -WindowStyle Hidden
          
          Write-Host "‚úÖ Sunshine (Moonlight Server) is now running in background."
          
          
      - name: üèÉ Keep Runner Alive (Max 6 Hours)
        shell: pwsh
        run: |
          $durationSeconds = $env:SESSION_DURATION_HOURS * 3600
          Write-Host "‚úÖ Runner is active for $env:SESSION_DURATION_HOURS hours. Session is ready."
          Write-Host "üëâ Connect via CRD: https://remotedesktop.google.com/access"
          Write-Host "üëâ Connect via ZeroTier/Sunshine: Find the device's assigned ZeroTier IP (requires authorization)."
          
          $seconds = $durationSeconds
          while ($seconds -gt 0) {
            Start-Sleep -Seconds 60
            $seconds -= 60
            if ($seconds % 300 -eq 0) { # Log every 5 minutes
              $minutesRemaining = [math]::Round($seconds/60)
              Write-Host "‚è≥ Time remaining: $minutesRemaining minutes..."
            }
          }

      - name: üí† Final Status
        if: always()
        shell: pwsh
        run: |
          Write-Host "‚úÖ Session Finished. Runner will now clean up."
